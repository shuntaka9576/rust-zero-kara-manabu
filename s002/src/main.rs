fn main() {
    println!("--- 2.1.1 ---");
    i2_1_1();
    println!("---");
    println!("--- 2.1.2 ---");
    i2_1_2();
    println!("---");
    println!("--- 2.1.3 ---");
    i2_1_3();
    println!("---");
    println!("--- 2.1.5 ---");
    i2_1_5();
    println!("---");
    println!("--- 2.1.6 ---");
    i2_1_6();
    println!("---");
    println!("--- 2.1.7 ---");
    i2_1_7();
    println!("---");
}

fn i2_1_7() {
    // 文字と文字列の型
    // Rustでは文字と文字列は別の型として扱う
    // 文字列スライスを宣言
    let a: &str = " Hello";
    // a += ", world!"; // コンパイルエラー

    let mut b: String = a.to_string();
    b += ", world!   ";

    let c: &str = b.trim();

    println!("c: [{c}]");

    // 複数行の文字列リテラル
    let d = r##"これは
"#複数行の#"
文字列"##;
    println!("{d}")
}

fn i2_1_6() {
    {
        // 配列とマクロ
        let arr: [u32; 4] = [1, 2, 3, 4];
        println!("{}, {}, {}, {}", arr[0], arr[1], arr[2], arr[3]);

        let s: &[u32] = &arr[1..3];
        println!("{:?}", s);
        println!("1以上3未満   &arr[1..3]: {:?}", &arr[1..3]);
        println!("1以上3以下   &arr[1..=3]: {:?}", &arr[1..=3]);
        println!("1以上        &arr[1..]: {:?}", &arr[1..]);
        println!("0以上、3未満 &arr[..3]: {:?}", &arr[..3]);

        println!("0以上、3以下 &arr[..3]: {:?}", &arr[..=3]);
        // スライスの範囲外アクセスは、panic
        // println!("0以上、3以下 &arr[..4]: {:?}", &arr[..=4]);

        // 配列の範囲外アクセスは、コンパイルエラー
        // コンパイルエラーは、静的解析で分かるわけではない(Rustの場合赤字で指摘されて、スタックトレース出てない時はコンパイルエラーと判断して良さそう
        //  arr[5];
    }
}

fn i2_1_5() {
    {
        // Rustはそのままの宣言だと、変更不可
        let a0 = 10;
        // a0 = 2; // compile error
        println!("a0: {a0}");

        // ミュートをつけると変更可能になる
        let mut n: u64 = 100; // nを破壊的代入可能として宣言し、100を代入
        n = 1;
        println!("n: {}", n);
    }

    {
        // 不変参照(&)の例
        let mut n: u64 = 100;

        let a: &u64 = &n; // aという参照型(reference type)へ不変参照を代入

        // *a = 200; // 不変参照なんで変更できない
        println!("*a(参照を外した値) = {}, addr(アドレス) = {:p}", *a, a);

        let b: &mut u64 = &mut n; // bという参照型にnの可変参照を代入(可変参照を受け取る時はbも改変参照の型でないとコンパイルエラーになる)
        *b = 200; // bのさしている先に200を破壊的代入
        println!("n = {n}");
    }

    {
        // 可変参照
        // let a: &u64 = &mut n;
    }

    // ミュートをつけると変更可能になる
    //let mut n: u64 = 100; // nを破壊的代入可能として宣言し、100を代入
    // let a: &u64 = &n; // aにnの不変参照を代入
    // println!("*a = {}, addr = {:p}", *a, a); // aを参照外した値(nの値)と、アドレスを表示

    // let b: &mut u64 = &mut n;
    // *b = 200;
    // println!("n = {n}");
}

fn i2_1_3() {
    println!("--- ビットシフト例(矢印の方向にシフトする) ---");

    let n: u8 = 0b0001_1000;
    let m: u8 = n << 2; // 2bit左シフト
    let k = n >> 2; // 2bit右シフト

    println!(
        "元データ: {}, 2ビット左シフト: {}, 2ビット右シフト: {}",
        n, m, k
    ); // 符号なし整数の場合は論理シフト

    println!("--- 算術シフト例 ---");
    let p: i8 = -64; // 0b1100_0000
    let k = p >> 2; // 2bit右算術シフト
    let k2 = p << 2; // 2bit左算術シフト
    println!("p:{}, k:{}, k2: {}", p, k, k2); // 符号あり整数の場合は、算術シフト

    println!("ビット演算");
    // 1 | 1の左1シフト | 568の左2シフト の論理和
    let player: u16 = 1 | // 毒状態
        (1 << 1) | // 1bit: 攻撃力アップ状態
        (568 << 2); // 2bit-15bit: 残り体力

    // a | b: aとbのビット論理和
    // a & B: aとbのビット論理積
    // a ^ b: aとbのビット排他的論理和

    // 1bitの目と1の論理積をとる。毒状態の場合 1&1 = 1 毒でない場合 0&1 = 0となる
    if player & 1 != 0 {
        println!("毒状態");
    }

    // 同様に論理積で、1ビット目から
    if player & (1 << 1) != 0 {
        println!("攻撃力アップ状態");
    }

    // 0xfffc = 0b1111_1111_1111_1100
    // 毒と攻撃力アップ状態を0との論理積で0埋め
    // 右シフトで体力だけの値を残す
    // => 0xfffcのような値はビットマスクと呼ばれる
    // マスクとビット論理積を計算することを「マスクする」と呼ぶ。
    let hp = (player & 0xfffc) >> 2;
    println!("残り体力: {hp}");
}

fn i2_1_2() {
    println!("{}", 1234 + 567);
    println!("{}", 678 - 168);
    println!("{}", 56 * 146);
    println!("{}", 542 / 43);
    println!("{}", 145 % 23);

    println!("{}", 1234 < 567);
    println!("{}", 678 <= 168);
    println!("{}", 56 > 146);
    println!("{}", 572 >= 43);
    println!("{}", 145 == 23);
}

fn i2_1_1() {
    println!("短絡評価");
    println!("{}", a() || b());

    println!("非短絡評価");
}

fn a() -> bool {
    print!("call a");
    true
}

fn b() -> bool {
    println!("call b");
    true
}
